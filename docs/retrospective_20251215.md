# プロジェクト振り返り (2025-12-15)

## 1. プロジェクトのゴールと現状
本プロジェクトは、MCP (Model Context Protocol) サーバを通じて物理演算・軌道計画・実行機能を提供し、AIエージェントが「正確なN体シミュレーション（Universe）」の中で自律的に宇宙航行を行うことを目標としていました。
これまでの成果物として、以下の2つのコンポーネントが実装されています。

*   **`universe`**: JAXを用いた高精度なN体物理エンジンおよび軌道計画器（`JAXPlanner`）。
*   **`web-viewer`**: 計算結果（JSON）を3D可視化するWebアプリケーション。

我々は「ガニメデ低軌道からカリスト低軌道への遷移」という具体的なシナリオを通じて、このシステムの実現可能性を検証してきました。

## 2. 直面した課題 (数値最適化の限界)
開発の過程で、**「数値最適化（Shooting Method / Boundary Value Problem）のロバスト性と計算コスト」** という重大な壁に直面しました。

### 主な問題点
1.  **収束性の低さと計算コスト**:
    *   有限燃焼（Finite Burn）を含む軌道計画において、初期値（Launch Time, Duration, Steering）に対する感度が極めて高く、ターゲット（カリスト高度100kmなど）に対する誤差を収束させるのに膨大な反復回数（15,000回以上）を要しました。
    *   JAXのJITコンパイルを活用してもなお、探索に数分〜数十分を要し、PC（MacBook）の発熱が深刻化しました。
2.  **局所解と初期値依存性**:
    *   単純なホーマン遷移に近い解であっても、N体摂動下では「わずかなタイミングのズレ」が「数千キロの誤差」に増幅されるため、少しでも悪い初期値から始めると、最適化ソルバが全く見当違いな解（衝突コースや脱出軌道）にトラップされる現象が多発しました。
3.  **データ整合性の維持の困難さ（Stitching Issue）**:
    *   「待機軌道」「噴射」「コースティング」「捕獲噴射」といった複数のフェーズを接続（Stitching）する際、時刻や座標系の不連続性が頻発しました。
    *   これらを解決するために複雑な「ログ結合ロジック（`add_log`）」や「重複検知・削除処理」を実装しましたが、これが新たなバグ（`Time Duplicate` や `dt=0` エラー）の温床となりました。

## 3. ガニメデ・カリスト遷移シナリオにおける具体的な困難の分析
直近のデバッグ（`ganymede_callisto_jax_lts.py`）において、以下の事象が確認されました。

*   **JAXPlannerの収束不全**:
    *   離脱噴射（Departure Burn）の最適化において、インパルス近似解（1.69 km/s）を初期値としたにもかかわらず、有限燃焼ソルバが最終誤差 **1700 km 〜 2200 km** を残したまま最大反復回数に到達しました。
    *   これは、重力損失（Gravity Loss）や多体摂動の影響をソルバが吸収しきれなかった、あるいは正則化項（Regularization）などの設定バランスが崩れていたことを示唆しています。
*   **バリデーションエラーの多発**:
    *   Validatorツールにより、**「Time Duplicate (dt=0.0s)」** エラーが繰り返し検出されました。
    *   これは、コースティングフェーズ（MCC〜Arrival間）の計算が、スクリプト上のロジックミス（`dt_to_arr`の算出不良）によりスキップされ、結果として「MCC終了時刻」と「捕獲開始時刻（数日後）」の軌道データが、不連続なまま接続されてしまったことに起因していました。
*   **人間には簡単だが機械には難しい**:
    *   人間であれば「近地点で加速すれば遠地点が伸びる」「カリストの公転に合わせてタイミングを計る」と直感的に計画できるものが、数値最適化にとっては「6次元空間における極めて急峻な谷底を探す」作業となり、非常に非効率でした。

**結論**: 
現状の「全てを数値最適化（Shooting法）で解く」というアプローチは、AIエージェントが自律的に扱うにはあまりに不安定であり、デバッグコストが高すぎます。

## 4. 方針転換の提案
プロジェクトの目標である「N体シミュレーションでの自律航行」を維持しつつ、アプローチを以下のように転換することを提案します。

### 新提案: 「Feedback Control & Primitive Navigation」
事前の「完全な軌道計画（Planning）」に依存するのではなく、**「リアルタイムのフィードバック制御と基本動作（Primitives）の組み合わせ」** によって航行を実現します。

1.  **PlanningからGuidance/Controlへのシフト**:
    *   出発前に全ての軌道を計算して固定するのではなく、エージェントは「現在の状態」と「目標」に基づいて、次の瞬間の行動を決定します。
    *   例：「近地点に到達したら加速」「ターゲット方向との角度偏差が閾値を超えたら修正」といったルールベース、あるいはMPC（Model Predictive Control）のような短期予測制御を採用します。
2.  **Navigation Primitives（航行基本動作）の導入**:
    *   複雑な遷移全体を一度に解くのではなく、以下のような小さな単位行動をAPIとして用意します。
        *   `HoldOrbit`: 現在の天体の周回軌道を維持する（ステーションキーピング）。
        *   `ChangeApoapsis`: 遠地点高度を変更する。
        *   `HohmannTransfer`: （パッチドコニック近似で計算した）マニューバを実行するが、**実行後の誤差は事後修正（TCM）で吸収する**。
        *   `Intercept`: ターゲットへの会合軌道に乗る。
3.  **「誤差を許容する」設計**:
    *   N体摂動によるズレは「計算ミス」ではなく「環境特性」として受け入れ、定期的な軌道修正マニューバ（TCM）によって能動的にキャンセルします。これは現実の宇宙機運用に即しています。

この方針により、計算コストを下げつつ、AIエージェントにとって「試行錯誤」や「リカバリー」が容易な環境を構築できると考えます。
パッチドコニック近似は「初期推測」としてのみ利用し、実際の航行と評価は厳密なN体物理演算で行うことで、安直なフォールバックにはなりません。
