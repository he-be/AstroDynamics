# 有限推力マヌーバ最適化：変分方程式アプローチに関する技術レポート

## 1. 背景
ガニメデ・カリスト遷移などの有限推力軌道計画において、シューティング法による補正計算（Jacobian計算）がパフォーマンスのボトルネックとなっていました。これを解消するため、数値微分（Finite Difference）から解析的微分（Analytical Gradients / Variational Equations）への移行を試みました。

## 2. 手法比較

### A. 既存手法：数値微分 (Finite Difference)
現在の `refine_finite_transfer` で採用されている手法です。

*   **仕組み**: 入力パラメータ（推力ベクトル $\mathbf{v}$）を微小量 $\epsilon$ だけずらして再計算し、その変化量から勾配を推定します。
*   **計算コスト**: Jacobian（3x3行列）を構築するために、1ステップあたり **4回の軌道伝播**（基準 + 各軸摂動）が必要です。
*   **メリット**: 実装が単純。コンパイル等の初期コストがほぼゼロ。
*   **デメリット**: 実行時間が遅い。$\epsilon$ の選び方により数値誤差や不安定性が生じる。

### B. 新手法：変分方程式 (Variational Equations)
Heyokaエンジンの機能を利用し、運動方程式と共に感度方程式（State Transition Matrix等）を同時に積分する手法です。

*   **仕組み**: 連鎖律（Chain Rule）を用いて、終端状態のパラメータに対する偏微分 $\frac{\partial \mathbf{r}_f}{\partial \mathbf{T}}$ を解析的に求めます。
*   **計算コスト**: 1ステップあたり **1回の軌道伝播**（ただし、変数は大幅に増える）。
*   **メリット**: 数学的に厳密な勾配が得られるため収束が早く、安定する。実行時パフォーマンスは理論上4倍以上向上する可能性がある。
*   **デメリット**: **初期コンパイル時間 (JIT) が極めて長い**。

## 3. 直面した課題：JITコンパイルのオーバーヘッド

Heyokaは高精度なテイラー級数積分を行うため、実行時に連立微分方程式系のC++コードを生成し、LLVM/Clangでコンパイルします。

*   **変数の爆発的増加**:
    *   通常の8天体N体問題: 49変数（位置・速度・質量）。
    *   変分方程式を含む系: 状態変数 $N=49$ に対し、STM（$N \times N$）とパラメータ感度（$N \times 3$）が追加されます。
    *   合計方程式数: $49 + 49^2 + 49 \times 3 \approx 2600$ 本。
*   **相互作用の複雑さ**: N体問題はすべての物体間（$N^2$）に重力が働く「密」な系であるため、その導関数（変分）の式は極めて長大になります。
*   **結果**: 最初の実行時に発生するJITコンパイルに、M1/M2 Mac環境で **5分〜10分以上** を要することが判明しました。
    *   土星を除外（N=43）して変数を約25%削減しても、コンパイル時間は劇的には改善しませんでした（コードの複雑性が $O(N^2)$ 以上で効いている可能性があります）。

## 4. 結論と推奨

現時点でのベンチマーク結果から、以下のことが言えます。

1.  **単発実行には不向き**: ゲームプレイ中やインタラクティブな操作で、その都度JITコンパイルが走る構成は実用的ではありません（待ち時間が長すぎる）。
2.  **バッチ処理なら有効**: 事前に数千〜数万通りのシナリオ計算を行う場合など、一度コンパイルしたカーネルを使い回す用途であれば、数値微分に対する速度優位性が発揮されます。
3.  **今後の対策案**:
    *   **Pre-compilation**: JITではなく、事前に共有ライブラリとしてコンパイル済みの積分器をロードする仕組みを構築する。
    *   **簡易モデルの利用**: シューティング（微分補正）の段階では、すべての衛星を含めず、木星＋対象衛星＋船だけの簡易3体モデル等で勾配を計算し、その結果をフルモデルに適用する「近似勾配法」を検討する。これにより変数 $N$ を劇的に減らし（$N \approx 19$）、コンパイル時間を短縮できる可能性があります。
